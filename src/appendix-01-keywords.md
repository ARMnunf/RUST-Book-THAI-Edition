## ภาคผนวก A: คำสงวน (Keywords)

รายการต่อไปนี้ประกอบด้วยคำสงวนที่ถูกสงวนไว้สำหรับการใช้งานในปัจจุบันหรืออนาคตโดยภาษา และไม่สามารถใช้เป็น identifiers (ยกเว้นใช้เป็น
as raw identifiers ซึ่งจะอธิบายไว้ในส่วน “[Raw
Identifiers][raw-identifiers]<!-- ignore -->”) Identifiers คือชื่อของฟังก์ชัน, ตัวแปร, พารามิเตอร์, ฟิลด์ของสตรัก, โมดูล, เครท(crates), ค่าคงที่, แมโคร, ค่าคงที่แบบ static, แอตทริบิวต์, ประเภท, trait หรือ lifetimes

[raw-identifiers]: #raw-identifiers

### คำสงวนที่ใช้งานอยู่ในปัจจุบัน

ต่อไปนี้คือรายการคำสงวนที่ใช้งานอยู่ในปัจจุบัน พร้อมคำอธิบายการทำงาน:

* `as` - ใช้สำหรับการแปลงประเภทข้อมูลพื้นฐาน, แยกแยะ trait เฉพาะที่มีรายการนั้น หรือเปลี่ยนชื่อรายการในคำสั่ง `use`
* `async` - ส่งคืน `Future` แทนที่จะบล็อกเธรดปัจจุบัน
* `await` - ระงับการทำงานจนกว่าผลลัพธ์ของ `Future` จะพร้อม
* `break` - ออกจากลูปทันที
* `const` - กำหนดรายการคงที่ (Constant Item) หรือตัวชี้คงที่แบบดิบ (Constant Raw Pointer)
* `continue` - ดำเนินการต่อไปยังการวนลูปรอบถัดไป
* `crate` - ในเส้นทางโมดูล อ้างอิงถึงรากของเครท
* `dyn` - การส่งแบบไดนามิก (dynamic dispatch) ไปยังออบเจ็กต์ trait
* `else` - ทางเลือกสำรองสำหรับโครงสร้างควบคุม `if` และ `if let`
* `enum` - สร้าง enumeration
* `extern` - เชื่อมโยงฟังก์ชันหรือตัวแปรภายนอก
* `false` - บูลีนค่าเท็จ
* `fn` - กำหนดฟังก์ชันหรือประเภทตัวชี้ฟังก์ชัน (function pointer type)
* `for` - วนลูปผ่านรายการจากตัวทำซ้ำ, ใช้งาน trait หรือระบุ lifetime ระดับสูงกว่า
* `if` - แยกสาขาตามผลลัพธ์ของนิพจน์เงื่อนไข
* `impl` - ใช้งานฟังก์ชันการทำงานแบบ inherent หรือ trait
* `in` - ส่วนหนึ่งของไวยากรณ์ลูป `for`
* `let` - ผูกตัวแปร
* `loop` - วนลูปแบบไม่มีเงื่อนไข
* `match` - จับคู่ค่ากับรูปแบบ
* `mod` - กำหนดโมดูล
* `move` - ทำให้ closure รับความเป็นเจ้าของทั้งหมดที่มันจับ
* `mut` - บ่งบอกความสามารถในการเปลี่ยนแปลงในการอ้างอิง, ตัวชี้แบบดิบ หรือการผูกรูปแบบ
* `pub` - บ่งบอกการมองเห็นสาธารณะในฟิลด์โครงสร้าง, บล็อก impl หรือโมดูล
* `ref` - ผูกโดยการอ้างอิง
* `return` - ส่งคืนจากฟังก์ชัน
* `Self` - นามแฝงประเภทสำหรับประเภทที่เรากำลังกำหนดหรือใช้งาน
* `self` - หัวข้อของเมธอดหรือโมดูลปัจจุบัน
* `static` - ตัวแปรหรืออายุการใช้งานทั่วโลกที่คงอยู่ตลอดการทำงานของโปรแกรม
* `struct` - กำหนดสตรัก
* `super` - โมดูลหลักของโมดูลปัจจุบัน
* `trait` - กำหนด trait
* `true` - บูลีนค่าจริง
* `type` - กำหนดนามแฝงประเภทหรือประเภทที่เกี่ยวข้อง
* `union` - กำหนด [union][union]<!-- ignore -->; เป็นคำสงวนเฉพาะเมื่อใช้ในการประกาศ union
* `unsafe` - บ่งบอกโค้ด, ฟังก์ชัน, trait หรือการใช้งานที่ไม่ปลอดภัย
* `use` - นำสัญลักษณ์เข้ามาในขอบเขต
* `where` - บ่งบอกข้อกำหนดที่จำกัดประเภท
* `while` - วนลูปตามเงื่อนไขโดยอิงจากผลลัพธ์ของนิพจน์

[union]: ../reference/items/unions.html

### คำสงวนสำหรับการใช้งานในอนาคต

คำสงวนต่อไปนี้ยังไม่มีฟังก์ชันการทำงานใด ๆ แต่ถูกสงวนไว้โดย Rust สำหรับการใช้งานที่อาจเกิดขึ้นในอนาคต

* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`

### ตัวระบุแบบดิบ (Raw Identifiers)

ตัวระบุแบบดิบ คือไวยากรณ์ที่ช่วยให้คุณสามารถใช้คำสงวนในที่ที่ปกติแล้วไม่อนุญาตให้ใช้ได้ คุณใช้ตัวระบุแบบดิบโดยเติมคำนำหน้า `r#` หน้าคำสงวน

ตัวอย่างเช่น `match` เป็นคำสงวน ถ้าคุณพยายามคอมไพล์ฟังก์ชันต่อไปนี้ที่ใช้ `match` เป็นชื่อ:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

คุณจะได้รับข้อผิดพลาดนี้:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

ข้อผิดพลาดแสดงว่าคุณไม่สามารถใช้คำสงวน `match` เป็นตัวระบุฟังก์ชันได้ ในการใช้ `match` เป็นชื่อฟังก์ชัน คุณต้องใช้ไวยากรณ์ตัวระบุแบบดิบ ดังนี้:

<span class="filename">Filename: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

โค้ดนี้จะคอมไพล์โดยไม่มีข้อผิดพลาดใด ๆ สังเกตคำนำหน้า `r#` ที่ชื่อฟังก์ชันในคำจำกัดความ รวมถึงที่ที่ฟังก์ชันถูกเรียกใน `main`

ตัวระบุแบบดิบช่วยให้คุณสามารถใช้คำใด ๆ ที่คุณเลือกเป็นตัวระบุได้ แม้ว่าคำนั้นจะเป็นคำสงวนก็ตาม สิ่งนี้ให้อิสระมากขึ้นในการเลือกชื่อตัวระบุ และช่วยให้เราสามารถบูรณาการกับโปรแกรมที่เขียนในภาษาอื่นที่คำเหล่านี้ไม่ใช่คำสงวนได้ นอกจากนี้ ตัวระบุแบบดิบยังช่วยให้คุณสามารถใช้ไลบรารีที่เขียนในเวอร์ชัน Rust ที่แตกต่างจากเครทของคุณได้ ตัวอย่างเช่น `try` ไม่ใช่คำสงวนในเวอร์ชัน 2015 แต่เป็นคำสงวนในเวอร์ชัน 2018 หากคุณต้องการใช้ไลบรารีที่เขียนด้วยเวอร์ชัน 2015 และมีฟังก์ชัน `try` คุณจะต้องใช้ไวยากรณ์ตัวระบุแบบดิบ `r#try` ในกรณีนี้เพื่อเรียกฟังก์ชันนั้นจากโค้ดเวอร์ชัน 2018 ของคุณ ดูที่ [ภาคผนวก E][appendix-e]<!-- ignore --> สำหรับข้อมูลเพิ่มเติมเกี่ยวกับเวอร์ชัน

[appendix-e]: appendix-05-editions.html
