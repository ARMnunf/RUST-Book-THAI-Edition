## สวัสดี, Cargo!

Cargo คือระบบการสร้างและตัวจัดการแพ็คเกจของ Rust 
นักพัฒนา Rust ส่วนใหญ่ใช้เครื่องมือนี้ในการจัดการโปรเจกต์ Rust .
เนื่องจาก Cargo จัดการงานหลายอย่างให้คุณ เช่น การสร้างโค้ดของคุณ การดาวน์โหลดไลบรารีที่โค้ดของคุณต้องการ 
และการสร้างไลบรารีเหล่านั้น (เราเรียกไลบรารีที่โค้ดของคุณต้องการว่า *dependencies*)

โปรแกรม Rust ที่เรียบง่ายที่สุด เช่นโปรแกรมที่เราเขียนไปแล้ว ไม่มี dependencies ใดๆ 
ถ้าเราสร้างโปรเจกต์ "Hello, world!" ด้วย Cargo มันจะใช้เฉพาะส่วนของ Cargo ที่จัดการกับการสร้างโค้ดของคุณเท่านั้น 
เมื่อคุณเขียนโปรแกรม Rust ที่ซับซ้อนขึ้น คุณจะเพิ่ม dependencies 
และถ้าคุณเริ่มโปรเจกต์โดยใช้ Cargo การเพิ่ม dependencies จะง่ายขึ้นมาก

เนื่องจากโปรเจกต์ Rust ส่วนใหญ่ใช้ Cargo หนังสือเล่มนี้จึงสมมติว่าคุณกำลังใช้ Cargo ด้วย 
Cargo มาพร้อมกับการติดตั้ง Rust ถ้าคุณใช้ตัวติดตั้งอย่างเป็นทางการตามที่กล่าวไว้ในส่วน ["การติดตั้ง"][installation] 
ถ้าคุณติดตั้ง Rust ด้วยวิธีอื่น ให้ตรวจสอบว่า Cargo ถูกติดตั้งหรือไม่โดยป้อนคำสั่งต่อไปนี้ในเทอร์มินัลของคุณ:

```console
$ cargo --version
```

ถ้าคุณเห็นหมายเลขเวอร์ชัน แสดงว่าคุณมีมันแล้ว! 
ถ้าคุณเห็นข้อผิดพลาด เช่น `command not found` ให้ดูที่คู่มือสำหรับวิธีการติดตั้งของคุณ
เพื่อกำหนดวิธีติดตั้ง Cargo แยกต่างหาก

### การสร้างโปรเจกต์ด้วย Cargo

มาสร้างโปรเจกต์ใหม่โดยใช้ Cargo และดูว่ามันแตกต่างจากโปรเจกต์ "Hello, world!" ดั้งเดิมของเราอย่างไร 
นำทางกลับไปที่ไดเรกทอรี *projects* ของคุณ (หรือที่ไหนก็ตามที่คุณตัดสินใจเก็บโค้ดของคุณ) 
จากนั้นบนระบบปฏิบัติการใดๆ ให้รันคำสั่งต่อไปนี้:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

คำสั่งแรกสร้างไดเรกทอรีใหม่และโปรเจกต์ชื่อ *hello_cargo* เราตั้งชื่อโปรเจกต์ของเราว่า *hello_cargo* 
และ Cargo สร้างไฟล์ต่างๆ ในไดเรกทอรีที่มีชื่อเดียวกัน

เข้าไปในไดเรกทอรี *hello_cargo* และแสดงรายการไฟล์ 
คุณจะเห็นว่า Cargo ได้สร้างไฟล์สองไฟล์และหนึ่งไดเรกทอรีให้เรา: ไฟล์ *Cargo.toml* 
และไดเรกทอรี *src* ที่มีไฟล์ *main.rs* อยู่ข้างใน

นอกจากนี้ยังได้สร้าง Git repository  ใหม่พร้อมกับไฟล์ *.gitignore* 
ไฟล์ Git จะไม่ถูกสร้างขึ้นถ้าคุณรัน `cargo new` ภายในพื้นที่เก็บ Git ที่มีอยู่แล้ว 
คุณสามารถแทนที่พฤติกรรมนี้ได้โดยใช้ `cargo new --vcs=git `

> หมายเหตุ: Git เป็นระบบควบคุมเวอร์ชันที่ใช้กันทั่วไป (version control)
> คุณสามารถเปลี่ยน `cargo new` ให้ใช้ระบบควบคุมเวอร์ชันตัวอื่น
> หรือไม่ใช้ระบบควบคุมเวอร์ชันได้โดยใช้ตัวเลือก `--vcs` รัน `cargo new --help` เพื่อดูตัวเลือกที่มีอยู่

เปิด *Cargo.toml* ในโปรแกรมเอดิเตอร์ที่คุณเลือก 
มันควรจะมีลักษณะคล้ายกับโค้ดในรายการ 1-2

<Listing number="1-2" file-name="Cargo.toml" caption="Contents of *Cargo.toml* generated by `cargo new`">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

</Listing>

ไฟล์นี้อยู่ในรูปแบบ [*TOML*][toml] (*Tom's Obvious, Minimal Language*) ซึ่งเป็นรูปแบบการกำหนดค่าของ Cargo

บรรทัดแรก `[package]` เป็นหัวข้อส่วนที่บ่งชี้ว่าคำสั่งต่อไปนี้กำลังกำหนดค่าแพ็คเกจ เมื่อเราเพิ่มข้อมูลเพิ่มเติมลงในไฟล์นี้ 
เราจะเพิ่มส่วนอื่นๆ

สามบรรทัดถัดไปตั้งค่าข้อมูลการกำหนดค่าที่ Cargo ต้องการเพื่อคอมไพล์โปรแกรมของคุณ: 
ชื่อ เวอร์ชัน และ edition ของ Rust ที่จะใช้ เราจะพูดถึงคีย์ `edition` ใน [ภาคผนวก E][appendix-e]

บรรทัดสุดท้าย `[dependencies]` เป็นจุดเริ่มต้นของส่วนที่คุณจะระบุ dependencies ของโปรเจกต์ของคุณ 
ใน Rust แพ็คเกจของโค้ดถูกเรียกว่า *crates* เราจะไม่ต้องการ crates อื่นๆ สำหรับโปรเจกต์นี้ 
แต่เราจะใช้ในโปรเจกต์แรกในบทที่ 2 ดังนั้นเราจะใช้ส่วน dependencies นี้ในตอนนั้น

ตอนนี้เปิด *src/main.rs* และดู:

<span class="filename">ชื่อไฟล์: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo ได้สร้างโปรแกรม "Hello, world!" ให้คุณ เหมือนกับที่เราเขียนในรายการ 1-1! 
จนถึงตอนนี้ความแตกต่างระหว่างโปรเจกต์ของเรากับโปรเจกต์ที่ Cargo สร้าง 
คือ Cargo วางโค้ดไว้ในไดเรกทอรี *src* และเรามีไฟล์การกำหนดค่า *Cargo.toml* ในไดเรกทอรีบนสุด

Cargo คาดหวังให้ไฟล์ต้นฉบับของคุณอยู่ภายในไดเรกทอรี *src* 
ไดเรกทอรีโปรเจกต์ระดับบนสุดมีไว้สำหรับไฟล์ README ข้อมูลใบอนุญาต (license information) ไฟล์การกำหนดค่า 
และสิ่งอื่นๆ ที่ไม่เกี่ยวข้องกับโค้ดของคุณ 
การใช้ Cargo ช่วยให้คุณจัดระเบียบโปรเจกต์ของคุณ มีที่สำหรับทุกอย่าง และทุกอย่างอยู่ในที่ของมัน

ถ้าคุณเริ่มโปรเจกต์ที่ไม่ใช้ Cargo เหมือนที่เราทำกับโปรเจกต์ "Hello, world!" 
คุณสามารถแปลงมันให้เป็นโปรเจกต์ที่ใช้ Cargo ได้ 
โดยย้ายโค้ดของโปรเจกต์ไปยังไดเรกทอรี *src* และสร้างไฟล์ *Cargo.toml* ที่เหมาะสม

### การสร้างและรันโปรเจกต์ Cargo

ตอนนี้มาดูว่ามีอะไรแตกต่างเมื่อเราสร้างและรันโปรแกรม "Hello, world!" ด้วย Cargo! 
จากไดเรกทอรี *hello_cargo* ของคุณ สร้างโปรเจกต์ของคุณโดยป้อนคำสั่งต่อไปนี้:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

คำสั่งนี้สร้างไฟล์ executable ใน *target/debug/hello_cargo* (หรือ *target\debug\hello_cargo.exe* บน Windows) 
แทนที่จะอยู่ในไดเรกทอรีปัจจุบันของคุณ เนื่องจากค่าเริ่มต้นของการสร้างเป็นการสร้างแบบดีบัก 
Cargo จึงใส่ไบนารีไว้ในไดเรกทอรีชื่อ *debug* คุณสามารถรันไฟล์ executable ได้ด้วยคำสั่งนี้:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

ถ้าทุกอย่างเป็นไปด้วยดี `Hello, world!` ควรจะพิมพ์ออกมาที่เทอร์มินัล 
การรัน `cargo build` เป็นครั้งแรกยังทำให้ Cargo สร้างไฟล์ใหม่ที่ระดับบนสุด: *Cargo.lock* 
ไฟล์นี้ติดตามเวอร์ชันที่แน่นอนของ dependencies ในโปรเจกต์ของคุณ โปรเจกต์นี้ไม่มี dependencies 
ดังนั้นไฟล์จึงค่อนข้างว่างเปล่า คุณไม่จำเป็นต้องแก้ไขไฟล์นี้ด้วยตนเอง Cargo จัดการเนื้อหาให้คุณ

เราเพิ่งสร้างโปรเจกต์ด้วย `cargo build` และรันมันด้วย `./target/debug/hello_cargo` 
แต่เราสามารถใช้ `cargo run` เพื่อคอมไพล์โค้ดและจากนั้นรันไฟล์ที่สามารถเรียกใช้งานได้ทั้งหมดในคำสั่งเดียว

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

การใช้ `cargo run` สะดวกกว่าการต้องจำว่าต้องรัน `cargo build` และจากนั้นใช้เส้นทางเต็มไปยังไบนารี 
ดังนั้นนักพัฒนาส่วนใหญ่จึงใช้ `cargo run`

สังเกตว่าครั้งนี้เราไม่เห็นผลลัพธ์ที่บ่งบอกว่า Cargo กำลังคอมไพล์ `hello_cargo` 
Cargo พบว่าไฟล์ไม่มีการเปลี่ยนแปลง จึงไม่ได้สร้างใหม่แต่เพียงแค่รันไบนารี 
ถ้าคุณได้แก้ไขซอร์สโค้ดของคุณ Cargo จะสร้างโปรเจกต์ใหม่ก่อนที่จะรัน และคุณจะเห็นผลลัพธ์นี้:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo ยังมีคำสั่งที่เรียกว่า `cargo check` 
คำสั่งนี้จะตรวจสอบโค้ดของคุณอย่างรวดเร็วเพื่อให้แน่ใจว่าสามารถคอมไพล์ได้ แต่ไม่ได้สร้างไฟล์ที่สามารถเรียกใช้งานได้:executable

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

ทำไมคุณถึงไม่ต้องการไฟล์ executable? บ่อยครั้งที่ `cargo check` เร็วกว่า `cargo build` มาก
เพราะมันข้ามขั้นตอนการสร้างไฟล์ที่สามารถเรียกใช้งานได้ ถ้าคุณตรวจสอบงานของคุณอย่างต่อเนื่องในขณะที่เขียนโค้ด 
การใช้ `cargo check` จะช่วยเร่งกระบวนการในการแจ้งให้คุณทราบว่าโปรเจกต์ของคุณยังคงคอมไพล์ได้อยู่หรือไม่! 
ด้วยเหตุนี้ นักพัฒนา Rust จำนวนมากจึงรัน `cargo check` เป็นระยะๆ ขณะที่เขียนโปรแกรมเพื่อให้แน่ใจว่ามันยังคอมไพล์ได้ 
จากนั้นพวกเขาจะรัน `cargo build` เมื่อพร้อมที่จะใช้ไฟล์ที่สามารถเรียกใช้งานได้

มาสรุปสิ่งที่เราได้เรียนรู้เกี่ยวกับ Cargo จนถึงตอนนี้:

* เราสามารถสร้างโปรเจกต์โดยใช้ `cargo new`
* เราสามารถสร้างโปรเจกต์โดยใช้ `cargo build`
* เราสามารถสร้างและรันโปรเจกต์ในขั้นตอนเดียวโดยใช้ `cargo run`
* เราสามารถสร้างโปรเจกต์โดยไม่สร้างไบนารีเพื่อตรวจสอบข้อผิดพลาดโดยใช้ `cargo check`
* แทนที่จะบันทึกผลลัพธ์ของการสร้างในไดเรกทอรีเดียวกับโค้ดของเรา 
  Cargo เก็บมันไว้ในไดเรกทอรี *target/debug*

ข้อดีเพิ่มเติมของการใช้ Cargo คือคำสั่งเหมือนกันไม่ว่าคุณจะทำงานบนระบบปฏิบัติการใด 
ดังนั้น ณ จุดนี้ เราจะไม่ให้คำแนะนำเฉพาะสำหรับ Linux และ macOS เทียบกับ Windows อีกต่อไป

### การสร้างสำหรับการเผยแพร่

เมื่อโปรเจกต์ของคุณพร้อมสำหรับการเผยแพร่ในที่สุด คุณสามารถใช้ `cargo build --release` 
เพื่อคอมไพล์ด้วยการเพิ่มประสิทธิภาพ คำสั่งนี้จะสร้างไฟล์ executable ใน *target/release* แทนที่จะเป็น *target/debug* 
การเพิ่มประสิทธิภาพทำให้โค้ด Rust ของคุณทำงานเร็วขึ้น 
แต่การเปิดใช้งานจะทำให้เวลาที่ใช้ในการคอมไพล์โปรแกรมของคุณนานขึ้น 
นี่คือเหตุผลที่มีโปรไฟล์สองแบบที่แตกต่างกัน: หนึ่งสำหรับการพัฒนาเมื่อคุณต้องการสร้างใหม่อย่างรวดเร็วและบ่อยครั้ง 
และอีกหนึ่งสำหรับการสร้างโปรแกรมสุดท้ายที่คุณจะให้ผู้ใช้ซึ่งจะไม่ถูกสร้างใหม่ซ้ำๆ และจะทำงานเร็วที่สุดเท่าที่จะเป็นไปได้ 
ถ้าคุณกำลังวัดเวลาการทำงานของโค้ดของคุณ ให้แน่ใจว่าได้รัน `cargo build --release` 
และทำการวัดประสิทธิภาพด้วยไฟล์ executable ใน *target/release*

### Cargo as Convention

สำหรับโปรเจกต์ง่ายๆ Cargo อาจไม่ได้มีคุณค่ามากนักเมื่อเทียบกับการใช้ `rustc` 
แต่มันจะแสดงคุณค่าเมื่อโปรแกรมของคุณซับซ้อนขึ้น 
เมื่อโปรแกรมเติบโตเป็นหลายไฟล์หรือต้องการ dependency การปล่อยให้ Cargo ประสานงานการสร้างจะง่ายกว่ามาก

แม้ว่าโปรเจกต์ `hello_cargo` จะเรียบง่าย it now uses much of the real
tooling you’ll use in the rest of your Rust career. 
ในความเป็นจริง เพื่อทำงานกับโปรเจกต์ที่มีอยู่ คุณสามารถใช้คำสั่งต่อไปนี้เพื่อตรวจสอบโค้ดโดยใช้ Git
เปลี่ยนไปยังไดเรกทอรีของโปรเจกต์นั้น และสร้าง:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

สำหรับข้อมูลเพิ่มเติมเกี่ยวกับ Cargo ให้ตรวจสอบ[เอกสารคู่มือ](https://doc.rust-lang.org/cargo/)

## สรุป

คุณได้เริ่มต้นการเดินทางในภาษา Rust อย่างยอดเยี่ยมแล้ว! ในบทนี้ คุณจะได้เรียนรู้:

* การติดตั้ง Rust เวอร์ชันเสถียรล่าสุดโดยใช้ `rustup`
* การอัปเดตเป็น Rust เวอร์ชันใหม่กว่า
* วิธีเปิดเอกสารคู่มือที่ติดตั้งเอาไว้ในเครื่อง
* เขียนและรันโปรแกรม "Hello, world!" โดยใช้ `rustc` โดยตรง
* สร้างและรันโปรเจกต์ใหม่โดยใช้ conventions of Cargo

นี่เป็นเวลาที่ดีในการสร้างโปรแกรมที่มีเนื้อหามากขึ้นเพื่อให้คุ้นเคยกับการอ่านและเขียนโค้ด Rust 
ดังนั้น ในบทที่ 2 เราจะสร้างโปรแกรมเกมทายตัวเลข 
ถ้าคุณต้องการเริ่มต้นด้วยการเรียนรู้วิธีการที่แนวคิดการเขียนโปรแกรมทั่วไปทำงานใน Rust ให้ดูบทที่ 3 และจากนั้นกลับมาที่บทที่ 2

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/
